## 305. Number of Islands II


```java

class Solution {
    public List<Integer> numIslands2(int m, int n, int[][] positions) {
        List<Integer> nums = new ArrayList<>();
        int[][] dicts = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        UnionFind uf = new UnionFind(m * n);
        for (int[] pos : positions) {
            int x = pos[0], y = pos[1];
            int curIndex = x * n + y;
            if (uf.parent[curIndex] == -1) { 
                uf.parent[curIndex] = curIndex;
                uf.numberOfSets++;
            }
            for (int[] dict : dicts) { 
                int newX = x + dict[0];
                int newY = y + dict[1];
                int nextIndex = curIndex + dict[0] * n + dict[1];                               
                if (newX >= 0 && newX < m 
                    && newY >= 0 && newY < n 
                    && uf.parent[nextIndex] != -1) {
                    uf.union(curIndex, nextIndex);
                }               
            }
            nums.add(uf.numberOfSets);
        }
        return nums;
    }
    
    class UnionFind {
        public int numberOfSets;
        public int[] parent;
        private int[] rank;
        public UnionFind(int size) {
            numberOfSets = 0;
            parent = new int[size];
            rank = new int[size];
            Arrays.fill(parent, -1);
        }
        
        private int find(int index) {            
            if (parent[index] != index) {
                parent[index] = find(parent[index]);
            }
            return parent[index];
        }
        
        public void union(int a, int b) {           
            int parentA = find(a);
            int parentB = find(b);
            
            if (parentA != parentB) {
                numberOfSets--;
                
                if (rank[parentA] > rank[parentB]) {
                    parent[parentB] = parentA;               
                } else if (rank[parentA] < rank[parentB]) {
                    parent[parentA] = parentB;                
                } else {
                    parent[parentB] = parentA;
                    rank[parentA]++;
                }
            }
        }
    }
}

```
