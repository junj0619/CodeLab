## 505. The Maze II

### Using Dijkstra Algorithm  

```java
class Solution {
    class Node {
        int x;
        int y;
        int val;
        Node(int x, int y, int val) {
            this.x = x;
            this.y = y;
            this.val = val;
        }
    }
    public int shortestDistance(int[][] maze, int[] start, int[] destination) {
        
        int rows = maze.length;
        int cols = maze[0].length;
        
        int[][] dicts = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        boolean[][] visited = new boolean[rows][cols];
        PriorityQueue<Node> pq = new PriorityQueue<>((a, b) -> (a.val - b.val));
        pq.offer(new Node(start[0], start[1], 0));
        visited[start[0]][start[1]] = true;
        
        while (!pq.isEmpty()) {
            Node cur = pq.poll();
            visited[cur.x][cur.y] = true;
            
            if (cur.x == destination[0] && cur.y == destination[1]) {
                return cur.val;
            }
            
            for (int[] dict : dicts) {
                int newX = cur.x;
                int newY = cur.y;
                int distance = cur.val;
                while (newX >= 0 && newX < rows 
                      && newY >= 0 && newY < cols
                      && maze[newX][newY] == 0) {
                    newX += dict[0];
                    newY += dict[1];
                    distance++;
                }
                newX -= dict[0];
                newY -= dict[1];
                distance--;
                
                if (!visited[newX][newY]) {                 
                    pq.offer(new Node(newX, newY, distance));
                }                
            }            
        }
        return -1;
    }
}

```
